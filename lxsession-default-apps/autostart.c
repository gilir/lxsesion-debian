/* autostart.c generated by valac 0.18.1, the Vala compiler
 * generated from autostart.vala, do not modify */

/* 
    Copyright 2013 Julien Lavergne <gilir@ubuntu.com>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <gtk/gtk.h>
#include <stdio.h>
#include <glib/gstdio.h>

#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _Block1Data Block1Data;
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
typedef struct _Block2Data Block2Data;
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))
#define _fclose0(var) ((var == NULL) ? NULL : (var = (fclose (var), NULL)))
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _Block1Data {
	int _ref_count_;
	GtkEntry* add_entry;
	GtkBuilder* builder;
};

struct _Block2Data {
	int _ref_count_;
	Block1Data * _data1_;
	GtkCheckButton* check;
};



gchar* ldefault_apps_read_autostart_conf (void);
gchar* ldefault_apps_get_config_home_path (const gchar* conf_file);
gchar* ldefault_apps_get_config_path (const gchar* conf_file);
void ldefault_apps_manual_autostart_init (GtkBuilder* builder);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static Block2Data* block2_data_ref (Block2Data* _data2_);
static void block2_data_unref (void * _userdata_);
static void ___lambda2_ (Block2Data* _data2_);
void ldefault_apps_update_autostart_conf (const gchar* line, const gchar* action, GtkBuilder* builder);
static void ____lambda2__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self);
static void ___lambda3_ (Block2Data* _data2_);
static void ____lambda3__gtk_button_clicked (GtkButton* _sender, gpointer self);
static void __lambda4_ (Block1Data* _data1_);
static void ___lambda4__gtk_button_clicked (GtkButton* _sender, gpointer self);
static gchar** _vala_array_dup1 (gchar** self, int length);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


gchar* ldefault_apps_read_autostart_conf (void) {
	gchar* result = NULL;
	gchar* config_path = NULL;
	gchar* _tmp0_ = NULL;
	const gchar* _tmp1_;
	GFile* _tmp2_ = NULL;
	GFile* config_file;
	GFile* _tmp3_;
	gboolean _tmp4_ = FALSE;
	GError * _inner_error_ = NULL;
	_tmp0_ = ldefault_apps_get_config_home_path ("autostart");
	_g_free0 (config_path);
	config_path = _tmp0_;
	_tmp1_ = config_path;
	_tmp2_ = g_file_new_for_path (_tmp1_);
	config_file = _tmp2_;
	_tmp3_ = config_file;
	_tmp4_ = g_file_query_exists (_tmp3_, NULL);
	if (!_tmp4_) {
		gchar* config_system_path = NULL;
		gchar* _tmp5_ = NULL;
		const gchar* _tmp6_;
		GFile* _tmp7_ = NULL;
		GFile* file;
		GFile* _tmp8_;
		GFile* _tmp9_ = NULL;
		GFile* config_parent;
		GFile* _tmp10_;
		gboolean _tmp11_ = FALSE;
		_tmp5_ = ldefault_apps_get_config_path ("autostart");
		_g_free0 (config_system_path);
		config_system_path = _tmp5_;
		_tmp6_ = config_system_path;
		_tmp7_ = g_file_new_for_path (_tmp6_);
		file = _tmp7_;
		_tmp8_ = config_file;
		_tmp9_ = g_file_get_parent (_tmp8_);
		config_parent = _tmp9_;
		_tmp10_ = config_parent;
		_tmp11_ = g_file_query_exists (_tmp10_, NULL);
		if (!_tmp11_) {
			{
				GFile* _tmp12_;
				_tmp12_ = config_parent;
				g_file_make_directory_with_parents (_tmp12_, NULL, &_inner_error_);
				if (_inner_error_ != NULL) {
					goto __catch0_g_error;
				}
			}
			goto __finally0;
			__catch0_g_error:
			{
				GError* e = NULL;
				GError* _tmp13_;
				const gchar* _tmp14_;
				e = _inner_error_;
				_inner_error_ = NULL;
				_tmp13_ = e;
				_tmp14_ = _tmp13_->message;
				g_message ("autostart.vala:41: %s", _tmp14_);
				_g_error_free0 (e);
			}
			__finally0:
			if (_inner_error_ != NULL) {
				_g_object_unref0 (config_parent);
				_g_object_unref0 (file);
				_g_free0 (config_system_path);
				_g_object_unref0 (config_file);
				_g_free0 (config_path);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		{
			GFile* _tmp15_;
			GFile* _tmp16_;
			_tmp15_ = file;
			_tmp16_ = config_file;
			g_file_copy (_tmp15_, _tmp16_, G_FILE_COPY_NONE, NULL, NULL, NULL, &_inner_error_);
			if (_inner_error_ != NULL) {
				goto __catch1_g_error;
			}
		}
		goto __finally1;
		__catch1_g_error:
		{
			GError* e = NULL;
			GError* _tmp17_;
			const gchar* _tmp18_;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp17_ = e;
			_tmp18_ = _tmp17_->message;
			g_message ("autostart.vala:51: %s", _tmp18_);
			_g_error_free0 (e);
		}
		__finally1:
		if (_inner_error_ != NULL) {
			_g_object_unref0 (config_parent);
			_g_object_unref0 (file);
			_g_free0 (config_system_path);
			_g_object_unref0 (config_file);
			_g_free0 (config_path);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_object_unref0 (config_parent);
		_g_object_unref0 (file);
		_g_free0 (config_system_path);
	}
	result = config_path;
	_g_object_unref0 (config_file);
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (void * _userdata_) {
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		_g_object_unref0 (_data1_->add_entry);
		_g_object_unref0 (_data1_->builder);
		g_slice_free (Block1Data, _data1_);
	}
}


static Block2Data* block2_data_ref (Block2Data* _data2_) {
	g_atomic_int_inc (&_data2_->_ref_count_);
	return _data2_;
}


static void block2_data_unref (void * _userdata_) {
	Block2Data* _data2_;
	_data2_ = (Block2Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data2_->_ref_count_)) {
		_g_object_unref0 (_data2_->check);
		block1_data_unref (_data2_->_data1_);
		_data2_->_data1_ = NULL;
		g_slice_free (Block2Data, _data2_);
	}
}


static gchar* g_file_stream_read_line (FILE* self) {
	gchar* result = NULL;
	gint c = 0;
	GString* ret;
	GString* _tmp7_;
	g_return_val_if_fail (self != NULL, NULL);
	ret = NULL;
	while (TRUE) {
		gint _tmp0_ = 0;
		gint _tmp1_;
		GString* _tmp2_;
		gint _tmp4_;
		GString* _tmp5_;
		gint _tmp6_;
		_tmp0_ = fgetc (self);
		c = _tmp0_;
		_tmp1_ = c;
		if (!(_tmp1_ != EOF)) {
			break;
		}
		_tmp2_ = ret;
		if (_tmp2_ == NULL) {
			GString* _tmp3_;
			_tmp3_ = g_string_new ("");
			_g_string_free0 (ret);
			ret = _tmp3_;
		}
		_tmp4_ = c;
		if (_tmp4_ == ((gint) '\n')) {
			break;
		}
		_tmp5_ = ret;
		_tmp6_ = c;
		g_string_append_c ((GString*) _tmp5_, (gchar) _tmp6_);
	}
	_tmp7_ = ret;
	if (_tmp7_ == NULL) {
		result = NULL;
		_g_string_free0 (ret);
		return result;
	} else {
		GString* _tmp8_;
		const gchar* _tmp9_;
		gchar* _tmp10_;
		_tmp8_ = ret;
		_tmp9_ = ((GString*) _tmp8_)->str;
		_tmp10_ = g_strdup (_tmp9_);
		result = _tmp10_;
		_g_string_free0 (ret);
		return result;
	}
	_g_string_free0 (ret);
}


static gchar* string_slice (const gchar* self, glong start, glong end) {
	gchar* result = NULL;
	gint _tmp0_;
	gint _tmp1_;
	glong string_length;
	glong _tmp2_;
	glong _tmp5_;
	gboolean _tmp8_ = FALSE;
	glong _tmp9_;
	gboolean _tmp12_;
	gboolean _tmp13_ = FALSE;
	glong _tmp14_;
	gboolean _tmp17_;
	glong _tmp18_;
	glong _tmp19_;
	glong _tmp20_;
	glong _tmp21_;
	glong _tmp22_;
	gchar* _tmp23_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = strlen (self);
	_tmp1_ = _tmp0_;
	string_length = (glong) _tmp1_;
	_tmp2_ = start;
	if (_tmp2_ < ((glong) 0)) {
		glong _tmp3_;
		glong _tmp4_;
		_tmp3_ = string_length;
		_tmp4_ = start;
		start = _tmp3_ + _tmp4_;
	}
	_tmp5_ = end;
	if (_tmp5_ < ((glong) 0)) {
		glong _tmp6_;
		glong _tmp7_;
		_tmp6_ = string_length;
		_tmp7_ = end;
		end = _tmp6_ + _tmp7_;
	}
	_tmp9_ = start;
	if (_tmp9_ >= ((glong) 0)) {
		glong _tmp10_;
		glong _tmp11_;
		_tmp10_ = start;
		_tmp11_ = string_length;
		_tmp8_ = _tmp10_ <= _tmp11_;
	} else {
		_tmp8_ = FALSE;
	}
	_tmp12_ = _tmp8_;
	g_return_val_if_fail (_tmp12_, NULL);
	_tmp14_ = end;
	if (_tmp14_ >= ((glong) 0)) {
		glong _tmp15_;
		glong _tmp16_;
		_tmp15_ = end;
		_tmp16_ = string_length;
		_tmp13_ = _tmp15_ <= _tmp16_;
	} else {
		_tmp13_ = FALSE;
	}
	_tmp17_ = _tmp13_;
	g_return_val_if_fail (_tmp17_, NULL);
	_tmp18_ = start;
	_tmp19_ = end;
	g_return_val_if_fail (_tmp18_ <= _tmp19_, NULL);
	_tmp20_ = start;
	_tmp21_ = end;
	_tmp22_ = start;
	_tmp23_ = g_strndup (((gchar*) self) + _tmp20_, (gsize) (_tmp21_ - _tmp22_));
	result = _tmp23_;
	return result;
}


static void ___lambda2_ (Block2Data* _data2_) {
	Block1Data* _data1_;
	GtkCheckButton* _tmp0_;
	const gchar* _tmp1_ = NULL;
	GtkCheckButton* _tmp2_;
	gboolean _tmp3_ = FALSE;
	_data1_ = _data2_->_data1_;
	g_message ("autostart.vala:88: Click !");
	_tmp0_ = _data2_->check;
	_tmp1_ = gtk_button_get_label ((GtkButton*) _tmp0_);
	g_message ("autostart.vala:89: Label to update : %s", _tmp1_);
	_tmp2_ = _data2_->check;
	_tmp3_ = gtk_toggle_button_get_active ((GtkToggleButton*) _tmp2_);
	if (_tmp3_) {
		GtkCheckButton* _tmp4_;
		const gchar* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		gchar* _tmp7_;
		gboolean _tmp8_;
		_tmp4_ = _data2_->check;
		_tmp5_ = gtk_button_get_label ((GtkButton*) _tmp4_);
		_tmp6_ = string_slice (_tmp5_, (glong) 0, (glong) 1);
		_tmp7_ = _tmp6_;
		_tmp8_ = g_strcmp0 (_tmp7_, "#") == 0;
		_g_free0 (_tmp7_);
		if (_tmp8_) {
			GtkCheckButton* _tmp9_;
			const gchar* _tmp10_ = NULL;
			GtkBuilder* _tmp11_;
			GtkCheckButton* _tmp12_;
			const gchar* _tmp13_ = NULL;
			_tmp9_ = _data2_->check;
			_tmp10_ = gtk_button_get_label ((GtkButton*) _tmp9_);
			_tmp11_ = _data1_->builder;
			ldefault_apps_update_autostart_conf (_tmp10_, "activate", _tmp11_);
			_tmp12_ = _data2_->check;
			_tmp13_ = gtk_button_get_label ((GtkButton*) _tmp12_);
			g_message ("autostart.vala:95: Activate : %s", _tmp13_);
		}
	} else {
		GtkCheckButton* _tmp14_;
		const gchar* _tmp15_ = NULL;
		gchar* _tmp16_ = NULL;
		gchar* _tmp17_;
		gboolean _tmp18_;
		_tmp14_ = _data2_->check;
		_tmp15_ = gtk_button_get_label ((GtkButton*) _tmp14_);
		_tmp16_ = string_slice (_tmp15_, (glong) 0, (glong) 1);
		_tmp17_ = _tmp16_;
		_tmp18_ = g_strcmp0 (_tmp17_, "#") != 0;
		_g_free0 (_tmp17_);
		if (_tmp18_) {
			GtkCheckButton* _tmp19_;
			const gchar* _tmp20_ = NULL;
			GtkBuilder* _tmp21_;
			GtkCheckButton* _tmp22_;
			const gchar* _tmp23_ = NULL;
			_tmp19_ = _data2_->check;
			_tmp20_ = gtk_button_get_label ((GtkButton*) _tmp19_);
			_tmp21_ = _data1_->builder;
			ldefault_apps_update_autostart_conf (_tmp20_, "desactivate", _tmp21_);
			_tmp22_ = _data2_->check;
			_tmp23_ = gtk_button_get_label ((GtkButton*) _tmp22_);
			g_message ("autostart.vala:103: Desactivate : %s", _tmp23_);
		}
	}
}


static void ____lambda2__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self) {
	___lambda2_ (self);
}


static void ___lambda3_ (Block2Data* _data2_) {
	Block1Data* _data1_;
	GtkCheckButton* _tmp0_;
	const gchar* _tmp1_ = NULL;
	GtkBuilder* _tmp2_;
	GtkCheckButton* _tmp3_;
	const gchar* _tmp4_ = NULL;
	_data1_ = _data2_->_data1_;
	g_message ("autostart.vala:112: Click !");
	_tmp0_ = _data2_->check;
	_tmp1_ = gtk_button_get_label ((GtkButton*) _tmp0_);
	_tmp2_ = _data1_->builder;
	ldefault_apps_update_autostart_conf (_tmp1_, "remove", _tmp2_);
	_tmp3_ = _data2_->check;
	_tmp4_ = gtk_button_get_label ((GtkButton*) _tmp3_);
	g_message ("autostart.vala:114: try to remove : %s", _tmp4_);
}


static void ____lambda3__gtk_button_clicked (GtkButton* _sender, gpointer self) {
	___lambda3_ (self);
}


static void __lambda4_ (Block1Data* _data1_) {
	const gchar* _tmp0_ = NULL;
	GtkBuilder* _tmp1_;
	g_message ("autostart.vala:130: Click !");
	_tmp0_ = gtk_entry_get_text (_data1_->add_entry);
	_tmp1_ = _data1_->builder;
	ldefault_apps_update_autostart_conf (_tmp0_, "add", _tmp1_);
	gtk_entry_set_text (_data1_->add_entry, "");
}


static void ___lambda4__gtk_button_clicked (GtkButton* _sender, gpointer self) {
	__lambda4_ (self);
}


void ldefault_apps_manual_autostart_init (GtkBuilder* builder) {
	Block1Data* _data1_;
	GtkBuilder* _tmp0_;
	GtkBuilder* _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	FILE* _tmp4_ = NULL;
	FILE* _tmp5_;
	FILE* stream;
	FILE* _tmp6_;
	gchar* _tmp7_ = NULL;
	gchar* _tmp8_;
	GtkBuilder* _tmp9_;
	GObject* _tmp10_ = NULL;
	GtkAlignment* _tmp11_;
	GtkAlignment* auto_align;
	GtkBuilder* _tmp12_;
	GObject* _tmp13_ = NULL;
	GtkVBox* _tmp14_;
	GtkVBox* auto_vbox;
	GtkVBox* _tmp15_;
	GList* _tmp16_ = NULL;
	gchar* line;
	GtkHBox* _tmp41_;
	GtkHBox* add_hbox;
	GtkButton* _tmp42_;
	GtkButton* add_button;
	GtkEntry* _tmp43_;
	GtkVBox* _tmp44_;
	GtkAlignment* _tmp45_;
	GtkVBox* _tmp46_;
	GtkVBox* _tmp47_;
	g_return_if_fail (builder != NULL);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_tmp0_ = builder;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (_data1_->builder);
	_data1_->builder = _tmp1_;
	_tmp2_ = ldefault_apps_read_autostart_conf ();
	_tmp3_ = _tmp2_;
	_tmp4_ = fopen (_tmp3_, "r");
	_tmp5_ = _tmp4_;
	_g_free0 (_tmp3_);
	stream = _tmp5_;
	_tmp6_ = stream;
	_vala_assert (_tmp6_ != NULL, "stream != null");
	_tmp7_ = ldefault_apps_read_autostart_conf ();
	_tmp8_ = _tmp7_;
	g_message ("autostart.vala:62: Autostart conf file : %s", _tmp8_);
	_g_free0 (_tmp8_);
	_tmp9_ = _data1_->builder;
	_tmp10_ = gtk_builder_get_object (_tmp9_, "autostart_alignment");
	_tmp11_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp10_, GTK_TYPE_ALIGNMENT) ? ((GtkAlignment*) _tmp10_) : NULL);
	auto_align = _tmp11_;
	_tmp12_ = _data1_->builder;
	_tmp13_ = gtk_builder_get_object (_tmp12_, "manual_autostart_vbox");
	_tmp14_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp13_, GTK_TYPE_VBOX) ? ((GtkVBox*) _tmp13_) : NULL);
	auto_vbox = _tmp14_;
	_tmp15_ = auto_vbox;
	_tmp16_ = gtk_container_get_children ((GtkContainer*) _tmp15_);
	{
		GList* widget_collection = NULL;
		GList* widget_it = NULL;
		widget_collection = _tmp16_;
		for (widget_it = widget_collection; widget_it != NULL; widget_it = widget_it->next) {
			GtkWidget* widget = NULL;
			widget = (GtkWidget*) widget_it->data;
			{
				GtkVBox* _tmp17_;
				GtkWidget* _tmp18_;
				_tmp17_ = auto_vbox;
				_tmp18_ = widget;
				gtk_container_remove ((GtkContainer*) _tmp17_, _tmp18_);
			}
		}
		_g_list_free0 (widget_collection);
	}
	line = NULL;
	while (TRUE) {
		Block2Data* _data2_;
		FILE* _tmp19_;
		gchar* _tmp20_ = NULL;
		const gchar* _tmp21_;
		const gchar* _tmp22_;
		GtkHBox* _tmp23_;
		GtkHBox* hbox;
		const gchar* _tmp24_;
		GtkCheckButton* _tmp25_;
		const gchar* _tmp26_;
		gchar* _tmp27_ = NULL;
		gchar* _tmp28_;
		gboolean _tmp29_;
		GtkCheckButton* _tmp32_;
		GtkHBox* _tmp33_;
		GtkCheckButton* _tmp34_;
		GtkButton* _tmp35_;
		GtkButton* button;
		GtkButton* _tmp36_;
		GtkHBox* _tmp37_;
		GtkButton* _tmp38_;
		GtkVBox* _tmp39_;
		GtkHBox* _tmp40_;
		_data2_ = g_slice_new0 (Block2Data);
		_data2_->_ref_count_ = 1;
		_data2_->_data1_ = block1_data_ref (_data1_);
		_tmp19_ = stream;
		_tmp20_ = g_file_stream_read_line (_tmp19_);
		_g_free0 (line);
		line = _tmp20_;
		_tmp21_ = line;
		if (!(_tmp21_ != NULL)) {
			block2_data_unref (_data2_);
			_data2_ = NULL;
			break;
		}
		_tmp22_ = line;
		g_message ("autostart.vala:75: Autostart line : %s", _tmp22_);
		_tmp23_ = (GtkHBox*) gtk_hbox_new (FALSE, 0);
		g_object_ref_sink (_tmp23_);
		hbox = _tmp23_;
		_tmp24_ = line;
		_tmp25_ = (GtkCheckButton*) gtk_check_button_new_with_label (_tmp24_);
		g_object_ref_sink (_tmp25_);
		_data2_->check = _tmp25_;
		_tmp26_ = line;
		_tmp27_ = string_slice (_tmp26_, (glong) 0, (glong) 1);
		_tmp28_ = _tmp27_;
		_tmp29_ = g_strcmp0 (_tmp28_, "#") == 0;
		_g_free0 (_tmp28_);
		if (_tmp29_) {
			GtkCheckButton* _tmp30_;
			_tmp30_ = _data2_->check;
			gtk_toggle_button_set_active ((GtkToggleButton*) _tmp30_, FALSE);
		} else {
			GtkCheckButton* _tmp31_;
			_tmp31_ = _data2_->check;
			gtk_toggle_button_set_active ((GtkToggleButton*) _tmp31_, TRUE);
		}
		_tmp32_ = _data2_->check;
		g_signal_connect_data ((GtkToggleButton*) _tmp32_, "toggled", (GCallback) ____lambda2__gtk_toggle_button_toggled, block2_data_ref (_data2_), (GClosureNotify) block2_data_unref, 0);
		_tmp33_ = hbox;
		_tmp34_ = _data2_->check;
		gtk_box_pack_start ((GtkBox*) _tmp33_, (GtkWidget*) _tmp34_, FALSE, FALSE, (guint) 0);
		_tmp35_ = (GtkButton*) gtk_button_new_from_stock ("gtk-remove");
		g_object_ref_sink (_tmp35_);
		button = _tmp35_;
		_tmp36_ = button;
		g_signal_connect_data (_tmp36_, "clicked", (GCallback) ____lambda3__gtk_button_clicked, block2_data_ref (_data2_), (GClosureNotify) block2_data_unref, 0);
		_tmp37_ = hbox;
		_tmp38_ = button;
		gtk_box_pack_start ((GtkBox*) _tmp37_, (GtkWidget*) _tmp38_, FALSE, FALSE, (guint) 0);
		_tmp39_ = auto_vbox;
		_tmp40_ = hbox;
		gtk_box_pack_start ((GtkBox*) _tmp39_, (GtkWidget*) _tmp40_, FALSE, FALSE, (guint) 0);
		_g_object_unref0 (button);
		_g_object_unref0 (hbox);
		block2_data_unref (_data2_);
		_data2_ = NULL;
	}
	_tmp41_ = (GtkHBox*) gtk_hbox_new (FALSE, 0);
	g_object_ref_sink (_tmp41_);
	add_hbox = _tmp41_;
	_tmp42_ = (GtkButton*) gtk_button_new_from_stock ("gtk-add");
	g_object_ref_sink (_tmp42_);
	add_button = _tmp42_;
	_tmp43_ = (GtkEntry*) gtk_entry_new ();
	g_object_ref_sink (_tmp43_);
	_data1_->add_entry = _tmp43_;
	gtk_box_pack_start ((GtkBox*) add_hbox, (GtkWidget*) add_button, FALSE, FALSE, (guint) 0);
	gtk_box_pack_start ((GtkBox*) add_hbox, (GtkWidget*) _data1_->add_entry, FALSE, FALSE, (guint) 0);
	_tmp44_ = auto_vbox;
	gtk_box_pack_start ((GtkBox*) _tmp44_, (GtkWidget*) add_hbox, FALSE, FALSE, (guint) 0);
	_tmp45_ = auto_align;
	_tmp46_ = auto_vbox;
	gtk_container_add ((GtkContainer*) _tmp45_, (GtkWidget*) _tmp46_);
	g_signal_connect_data (add_button, "clicked", (GCallback) ___lambda4__gtk_button_clicked, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
	_tmp47_ = auto_vbox;
	gtk_widget_show_all ((GtkWidget*) _tmp47_);
	_g_object_unref0 (add_button);
	_g_object_unref0 (add_hbox);
	_g_free0 (line);
	_g_object_unref0 (auto_vbox);
	_g_object_unref0 (auto_align);
	_fclose0 (stream);
	block1_data_unref (_data1_);
	_data1_ = NULL;
}


void ldefault_apps_update_autostart_conf (const gchar* line, const gchar* action, GtkBuilder* builder) {
	GString* _tmp0_;
	GString* new_line;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	GQuark _tmp4_ = 0U;
	static GQuark _tmp3_label0 = 0;
	static GQuark _tmp3_label1 = 0;
	static GQuark _tmp3_label2 = 0;
	static GQuark _tmp3_label3 = 0;
	GError * _inner_error_ = NULL;
	g_return_if_fail (line != NULL);
	g_return_if_fail (action != NULL);
	g_return_if_fail (builder != NULL);
	_tmp0_ = g_string_new ("");
	new_line = _tmp0_;
	_tmp1_ = action;
	_tmp2_ = _tmp1_;
	_tmp4_ = (NULL == _tmp2_) ? 0 : g_quark_from_string (_tmp2_);
	if (_tmp4_ == ((0 != _tmp3_label0) ? _tmp3_label0 : (_tmp3_label0 = g_quark_from_static_string ("activate")))) {
		switch (0) {
			default:
			{
				GString* _tmp5_;
				const gchar* _tmp6_;
				GString* _tmp7_;
				GString* _tmp8_;
				_tmp5_ = new_line;
				_tmp6_ = line;
				g_string_append (_tmp5_, _tmp6_);
				_tmp7_ = new_line;
				g_string_erase (_tmp7_, (gssize) 0, (gssize) 1);
				_tmp8_ = new_line;
				g_string_append (_tmp8_, "\n");
				break;
			}
		}
	} else if (_tmp4_ == ((0 != _tmp3_label1) ? _tmp3_label1 : (_tmp3_label1 = g_quark_from_static_string ("desactivate")))) {
		switch (0) {
			default:
			{
				GString* _tmp9_;
				GString* _tmp10_;
				const gchar* _tmp11_;
				GString* _tmp12_;
				_tmp9_ = new_line;
				g_string_append (_tmp9_, "#");
				_tmp10_ = new_line;
				_tmp11_ = line;
				g_string_append (_tmp10_, _tmp11_);
				_tmp12_ = new_line;
				g_string_append (_tmp12_, "\n");
				break;
			}
		}
	} else if (_tmp4_ == ((0 != _tmp3_label2) ? _tmp3_label2 : (_tmp3_label2 = g_quark_from_static_string ("add")))) {
		switch (0) {
			default:
			{
				GString* _tmp13_;
				const gchar* _tmp14_;
				GString* _tmp15_;
				_tmp13_ = new_line;
				_tmp14_ = line;
				g_string_append (_tmp13_, _tmp14_);
				_tmp15_ = new_line;
				g_string_append (_tmp15_, "\n");
				break;
			}
		}
	} else if (_tmp4_ == ((0 != _tmp3_label3) ? _tmp3_label3 : (_tmp3_label3 = g_quark_from_static_string ("remove")))) {
		switch (0) {
			default:
			{
				break;
			}
		}
	}
	{
		const gchar* _tmp16_ = NULL;
		gchar* _tmp17_ = NULL;
		gchar* tmp_path;
		const gchar* _tmp18_;
		GFile* _tmp19_ = NULL;
		GFile* tmp_file;
		gchar* _tmp20_ = NULL;
		gchar* _tmp21_;
		GFile* _tmp22_ = NULL;
		GFile* _tmp23_;
		GFile* dest_file;
		gchar* _tmp24_ = NULL;
		gchar* _tmp25_;
		FILE* _tmp26_ = NULL;
		FILE* _tmp27_;
		FILE* stream;
		GFile* _tmp28_;
		GFileOutputStream* _tmp29_ = NULL;
		GFileOutputStream* _tmp30_;
		GFileOutputStream* _tmp31_;
		GDataOutputStream* _tmp32_;
		GDataOutputStream* _tmp33_;
		GDataOutputStream* tmp_stream;
		FILE* _tmp34_;
		gchar* read;
		const gchar* _tmp48_;
		GFile* _tmp52_;
		GFile* _tmp53_;
		GFile* _tmp54_;
		GtkBuilder* _tmp55_;
		_tmp16_ = g_get_user_cache_dir ();
		_tmp17_ = g_build_filename (_tmp16_, "lxsession-default-apps", "autostart.tmp", NULL);
		tmp_path = _tmp17_;
		_tmp18_ = tmp_path;
		_tmp19_ = g_file_new_for_path (_tmp18_);
		tmp_file = _tmp19_;
		_tmp20_ = ldefault_apps_read_autostart_conf ();
		_tmp21_ = _tmp20_;
		_tmp22_ = g_file_new_for_path (_tmp21_);
		_tmp23_ = _tmp22_;
		_g_free0 (_tmp21_);
		dest_file = _tmp23_;
		_tmp24_ = ldefault_apps_read_autostart_conf ();
		_tmp25_ = _tmp24_;
		_tmp26_ = fopen (_tmp25_, "r");
		_tmp27_ = _tmp26_;
		_g_free0 (_tmp25_);
		stream = _tmp27_;
		_tmp28_ = tmp_file;
		_tmp29_ = g_file_create (_tmp28_, G_FILE_CREATE_REPLACE_DESTINATION, NULL, &_inner_error_);
		_tmp30_ = _tmp29_;
		if (_inner_error_ != NULL) {
			_fclose0 (stream);
			_g_object_unref0 (dest_file);
			_g_object_unref0 (tmp_file);
			_g_free0 (tmp_path);
			goto __catch2_g_error;
		}
		_tmp31_ = _tmp30_;
		_tmp32_ = g_data_output_stream_new ((GOutputStream*) _tmp31_);
		_tmp33_ = _tmp32_;
		_g_object_unref0 (_tmp31_);
		tmp_stream = _tmp33_;
		_tmp34_ = stream;
		_vala_assert (_tmp34_ != NULL, "stream != null");
		read = NULL;
		while (TRUE) {
			FILE* _tmp35_;
			gchar* _tmp36_ = NULL;
			const gchar* _tmp37_;
			const gchar* _tmp38_;
			const gchar* _tmp39_;
			const gchar* _tmp40_;
			const gchar* _tmp41_;
			_tmp35_ = stream;
			_tmp36_ = g_file_stream_read_line (_tmp35_);
			_g_free0 (read);
			read = _tmp36_;
			_tmp37_ = read;
			if (!(_tmp37_ != NULL)) {
				break;
			}
			_tmp38_ = read;
			g_message ("autostart.vala:173: read : %s", _tmp38_);
			_tmp39_ = line;
			g_message ("autostart.vala:174: line : %s", _tmp39_);
			_tmp40_ = read;
			_tmp41_ = line;
			if (g_strcmp0 (_tmp40_, _tmp41_) == 0) {
				GDataOutputStream* _tmp42_;
				GString* _tmp43_;
				const gchar* _tmp44_;
				_tmp42_ = tmp_stream;
				_tmp43_ = new_line;
				_tmp44_ = _tmp43_->str;
				g_data_output_stream_put_string (_tmp42_, _tmp44_, NULL, &_inner_error_);
				if (_inner_error_ != NULL) {
					_g_free0 (read);
					_g_object_unref0 (tmp_stream);
					_fclose0 (stream);
					_g_object_unref0 (dest_file);
					_g_object_unref0 (tmp_file);
					_g_free0 (tmp_path);
					goto __catch2_g_error;
				}
			} else {
				GDataOutputStream* _tmp45_;
				const gchar* _tmp46_;
				GDataOutputStream* _tmp47_;
				_tmp45_ = tmp_stream;
				_tmp46_ = read;
				g_data_output_stream_put_string (_tmp45_, _tmp46_, NULL, &_inner_error_);
				if (_inner_error_ != NULL) {
					_g_free0 (read);
					_g_object_unref0 (tmp_stream);
					_fclose0 (stream);
					_g_object_unref0 (dest_file);
					_g_object_unref0 (tmp_file);
					_g_free0 (tmp_path);
					goto __catch2_g_error;
				}
				_tmp47_ = tmp_stream;
				g_data_output_stream_put_string (_tmp47_, "\n", NULL, &_inner_error_);
				if (_inner_error_ != NULL) {
					_g_free0 (read);
					_g_object_unref0 (tmp_stream);
					_fclose0 (stream);
					_g_object_unref0 (dest_file);
					_g_object_unref0 (tmp_file);
					_g_free0 (tmp_path);
					goto __catch2_g_error;
				}
			}
		}
		_tmp48_ = action;
		if (g_strcmp0 (_tmp48_, "add") == 0) {
			GDataOutputStream* _tmp49_;
			GString* _tmp50_;
			const gchar* _tmp51_;
			_tmp49_ = tmp_stream;
			_tmp50_ = new_line;
			_tmp51_ = _tmp50_->str;
			g_data_output_stream_put_string (_tmp49_, _tmp51_, NULL, &_inner_error_);
			if (_inner_error_ != NULL) {
				_g_free0 (read);
				_g_object_unref0 (tmp_stream);
				_fclose0 (stream);
				_g_object_unref0 (dest_file);
				_g_object_unref0 (tmp_file);
				_g_free0 (tmp_path);
				goto __catch2_g_error;
			}
		}
		_tmp52_ = tmp_file;
		_tmp53_ = dest_file;
		g_file_copy (_tmp52_, _tmp53_, G_FILE_COPY_OVERWRITE, NULL, NULL, NULL, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_free0 (read);
			_g_object_unref0 (tmp_stream);
			_fclose0 (stream);
			_g_object_unref0 (dest_file);
			_g_object_unref0 (tmp_file);
			_g_free0 (tmp_path);
			goto __catch2_g_error;
		}
		_tmp54_ = tmp_file;
		g_file_delete (_tmp54_, NULL, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_free0 (read);
			_g_object_unref0 (tmp_stream);
			_fclose0 (stream);
			_g_object_unref0 (dest_file);
			_g_object_unref0 (tmp_file);
			_g_free0 (tmp_path);
			goto __catch2_g_error;
		}
		_tmp55_ = builder;
		ldefault_apps_manual_autostart_init (_tmp55_);
		_g_free0 (read);
		_g_object_unref0 (tmp_stream);
		_fclose0 (stream);
		_g_object_unref0 (dest_file);
		_g_object_unref0 (tmp_file);
		_g_free0 (tmp_path);
	}
	goto __finally2;
	__catch2_g_error:
	{
		GError* e = NULL;
		GError* _tmp56_;
		const gchar* _tmp57_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp56_ = e;
		_tmp57_ = _tmp56_->message;
		g_message ("autostart.vala:198: %s", _tmp57_);
		_g_error_free0 (e);
	}
	__finally2:
	if (_inner_error_ != NULL) {
		_g_string_free0 (new_line);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_string_free0 (new_line);
}


gchar* ldefault_apps_get_config_home_path (const gchar* conf_file) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* user_config_dir;
	g_return_val_if_fail (conf_file != NULL, NULL);
	_tmp0_ = g_get_user_config_dir ();
	_tmp1_ = g_getenv ("DESKTOP_SESSION");
	_tmp2_ = conf_file;
	_tmp3_ = g_build_filename (_tmp0_, "lxsession", _tmp1_, _tmp2_, NULL);
	user_config_dir = _tmp3_;
	result = user_config_dir;
	return result;
}


static gchar** _vala_array_dup1 (gchar** self, int length) {
	gchar** result;
	int i;
	result = g_new0 (gchar*, length + 1);
	for (i = 0; i < length; i++) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


gchar* ldefault_apps_get_config_path (const gchar* conf_file) {
	gchar* result = NULL;
	gchar* final_config_file = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* user_config_dir;
	const gchar* _tmp2_;
	gboolean _tmp3_ = FALSE;
	const gchar* _tmp24_;
	g_return_val_if_fail (conf_file != NULL, NULL);
	_tmp0_ = conf_file;
	_tmp1_ = ldefault_apps_get_config_home_path (_tmp0_);
	user_config_dir = _tmp1_;
	_tmp2_ = user_config_dir;
	_tmp3_ = g_file_test (_tmp2_, G_FILE_TEST_EXISTS);
	if (_tmp3_) {
		const gchar* _tmp4_;
		const gchar* _tmp5_;
		gchar* _tmp6_;
		_tmp4_ = user_config_dir;
		g_message ("autostart.vala:226: User config used : %s", _tmp4_);
		_tmp5_ = user_config_dir;
		_tmp6_ = g_strdup (_tmp5_);
		_g_free0 (final_config_file);
		final_config_file = _tmp6_;
	} else {
		gchar** _tmp7_;
		gchar** _tmp8_ = NULL;
		gchar** _tmp9_;
		gint _tmp9__length1;
		gchar** system_config_dirs;
		gint system_config_dirs_length1;
		gint _system_config_dirs_size_;
		gchar* config_system_location;
		gchar* path_system_config_file;
		gchar** _tmp10_;
		gint _tmp10__length1;
		const gchar* _tmp21_;
		const gchar* _tmp22_;
		gchar* _tmp23_;
		_tmp8_ = _tmp7_ = g_get_system_config_dirs ();
		_tmp9_ = (_tmp8_ != NULL) ? _vala_array_dup1 (_tmp8_, _vala_array_length (_tmp7_)) : ((gpointer) _tmp8_);
		_tmp9__length1 = _vala_array_length (_tmp7_);
		system_config_dirs = _tmp9_;
		system_config_dirs_length1 = _tmp9__length1;
		_system_config_dirs_size_ = system_config_dirs_length1;
		config_system_location = NULL;
		path_system_config_file = NULL;
		_tmp10_ = system_config_dirs;
		_tmp10__length1 = system_config_dirs_length1;
		{
			gchar** config_collection = NULL;
			gint config_collection_length1 = 0;
			gint _config_collection_size_ = 0;
			gint config_it = 0;
			config_collection = _tmp10_;
			config_collection_length1 = _tmp10__length1;
			for (config_it = 0; config_it < _tmp10__length1; config_it = config_it + 1) {
				gchar* _tmp11_;
				gchar* config = NULL;
				_tmp11_ = g_strdup (config_collection[config_it]);
				config = _tmp11_;
				{
					const gchar* _tmp12_;
					const gchar* _tmp13_ = NULL;
					gchar* _tmp14_ = NULL;
					const gchar* _tmp15_;
					const gchar* _tmp16_;
					gboolean _tmp17_ = FALSE;
					_tmp12_ = config;
					_tmp13_ = g_getenv ("DESKTOP_SESSION");
					_tmp14_ = g_build_filename (_tmp12_, "lxsession", _tmp13_, NULL);
					_g_free0 (config_system_location);
					config_system_location = _tmp14_;
					_tmp15_ = config_system_location;
					g_message ("autostart.vala:237: Config system location : %s", _tmp15_);
					_tmp16_ = config_system_location;
					_tmp17_ = g_file_test (_tmp16_, G_FILE_TEST_EXISTS);
					if (_tmp17_) {
						const gchar* _tmp18_;
						const gchar* _tmp19_;
						gchar* _tmp20_ = NULL;
						_tmp18_ = config_system_location;
						_tmp19_ = conf_file;
						_tmp20_ = g_build_filename (_tmp18_, _tmp19_, NULL);
						_g_free0 (path_system_config_file);
						path_system_config_file = _tmp20_;
						_g_free0 (config);
						break;
					}
					_g_free0 (config);
				}
			}
		}
		_tmp21_ = path_system_config_file;
		g_message ("autostart.vala:243: System system path location : %s", _tmp21_);
		_tmp22_ = path_system_config_file;
		_tmp23_ = g_strdup (_tmp22_);
		_g_free0 (final_config_file);
		final_config_file = _tmp23_;
		_g_free0 (path_system_config_file);
		_g_free0 (config_system_location);
		system_config_dirs = (_vala_array_free (system_config_dirs, system_config_dirs_length1, (GDestroyNotify) g_free), NULL);
	}
	_tmp24_ = final_config_file;
	g_message ("autostart.vala:247: Final file used : %s", _tmp24_);
	result = final_config_file;
	_g_free0 (user_config_dir);
	return result;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



